/* Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved. */
/* ------------------------------------------------------ */
/* -------------------- amx-tag.js ---------------------- */
/* ------------------------------------------------------ */

(function()
{
  // ------ AMX Tag ------ //
  /**
   * AMX tag object. JS object representation of the AMX node definition from the AMX page.
   * Constructor should only be by the framework.
   *
   * @param {(adf.mf.api.amx.AmxTag|null)} parentTag the parent tag or null for the root.
   * @param {Node} xmlNode the XML DOM node from the AMX page
   * @param {Array.<number>} nextAutoGeneratedId an array with a single integer (to be able
   *        to change the value) for tags without IDs, the next auto-generated
   *        one to use.
   * @constructor adf.mf.api.amx.AmxTag
   * @augments adf.mf.api.AdfObject
   */
  function AmxTag(
    parentTag,
    xmlNode,
    nextAutoGeneratedId)
  {
    this.Init(parentTag, xmlNode, nextAutoGeneratedId);
  }

  adf.mf.api.amx.AmxTag = AmxTag;
  adf.mf.api.AdfObject.createSubclass(adf.mf.api.amx.AmxTag, adf.mf.api.AdfObject,
    "adf.mf.api.amx.AmxTag");

  adf.mf.api.amx.AmxTag.prototype.Init = function(
    parentTag,
    xmlNode,
    nextAutoGeneratedId)
  {
    AmxTag.superclass.Init.call(this);

    // TODO assert that xmlNode != null and xmlNode.nodeType == 1
    this._parent = parentTag;
    // The native xml parser in UWP has namespaceUri vs namespaceURI
    this._ns = xmlNode.namespaceURI || xmlNode.namespaceUri;
    this._prefixedName = xmlNode.tagName;
    this._name = xmlNode.localName;
    this._nsPrefixedName = this._ns + ":" + this._name;
    this._textContent = "";
    this._elDependencies = null;
    this._attr = {};
    this._uiTag = null;

    if (this._name == "parsererror")
    {
      // The native xml parser in UWP has innerText vs textContent
      var errorText = xmlNode.textContent || xmlNode.innerText;
      if (adf.mf.environment.profile.mockData)
        console.log("*** " + errorText); // make more obvious error for mock mode
      throw new Error(adf.mf.resource.getInfoString("AMXErrorBundle",
        "ERROR_XML_PARSING_ERROR", errorText));
    }

    var attrs = xmlNode.attributes;
    var i, size;
    var idFound = false;

    for (i = 0, size = attrs.length; i < size; ++i)
    {
      var a = attrs[i];
      this._attr[a.name] = a.value;
      if (idFound == false && a.name == "id")
      {
        idFound = true;
      }
    }

    if (!idFound)
    {
      // Assign a unique ID to the tag
      if (nextAutoGeneratedId == null)
      {
        nextAutoGeneratedId = [ 0 ];
      }

      this._attr["id"] = "_auto" + (nextAutoGeneratedId[0]++);
    }

    this._children = [];
    var children = xmlNode.childNodes;
    for (i = 0, size = children.length; i < size; ++i)
    {
      var child = children[i];

      switch (child.nodeType)
      {
        case 1: // element
          var tag = new adf.mf.api.amx.AmxTag(this, child, nextAutoGeneratedId);
          this._children.push(tag);
          break;
        case 3: // text node
        case 4: // CDATA node
          if (this._textContent == null)
          {
            // First text or CDATA node encountered. Note: innerText is for UWP
            this._textContent = child.textContent || child.innerText;
          }
          else
          {
            // Subsequent text or CDATA nodes. Note: innerText is for UWP
            this._textContent += child.textContent || child.innerText;
          }
          break;
      }
    }
  };

  AmxTag.NAMESPACE_AMX = "http://xmlns.oracle.com/adf/mf/amx";
  AmxTag.NAMESPACE_DVTM = AmxTag.NAMESPACE_AMX + "/dvt";

  /**
   * Get the XML namespace URI for the tag.
   * @return {string} the namespace URI
   */
  adf.mf.api.amx.AmxTag.prototype.getNamespace = function()
  {
    return this._ns;
  };

  /**
   * @deprecated
   */
  adf.mf.api.amx.AmxTag.prototype.getPrefixedName = function()
  {
    adf.mf.log.logInfoResource("AMXInfoBundle", adf.mf.log.level.SEVERE,
      "AmxTag.getPrefixedName", "MSG_DEPRECATED", "amxTag.getPrefixedName",
      "Use amxTag.getNsPrefixedName instead.");
    return this._prefixedName;
  };

  /**
   * Return the tag name including the namespace prefix (not the local xmlns prefix).
   * This is the full XML name like "http://xmlns.example.com/custom:custom".
   * @return {string} the tag name with the prefix
   */
  adf.mf.api.amx.AmxTag.prototype.getNsPrefixedName = function()
  {
    return this._nsPrefixedName;
  };

  /**
   * Get the tag name. This is the local XML tag name without the prefix.
   * @return {string} the tag name
   */
  adf.mf.api.amx.AmxTag.prototype.getName = function()
  {
    return this._name;
  };

  /**
   * Get the parent tag.
   * @return {(adf.mf.api.amx.AmxTag|null)} the parent tag or null for the top level
   *         tag.
   */
  adf.mf.api.amx.AmxTag.prototype.getParent = function()
  {
    return this._parent;
  };

  /**
   * Returns the text content of the tag.
   * @return {string} the text content, or an empty string.
   */
  adf.mf.api.amx.AmxTag.prototype.getTextContent = function()
  {
    return this._textContent;
  };

  /**
   * Recursively search the tag hierarchy for tags with the given
   * namespace and tag name. Returns the current tag if a match as well.
   *
   * @param {string} namespace the namespace of the children to retrieve.
   * @param {string} tagName the name of the tags to return.
   * @return {Array.<adf.mf.api.amx.AmxTag>} array of all the matching tags.
   */
  adf.mf.api.amx.AmxTag.prototype.findTags = function(
    namespace,
    tagName)
  {
    var tags = [];
    if (tagName == this.getName() && this.getNamespace() == namespace)
    {
      tags.push(this);
    }

    for (var i = 0, size = this._children.length; i < size; ++i)
    {
      var child = this._children[i];
      var result = child.findTags(namespace, tagName);
      if (result.length > 0)
      {
        tags = tags.concat(result);
      }
    }

    return tags;
  };

  /**
   * Get the children of the tag. Provides for optional filtering of the children
   * namespaces and tag names.
   * @param {(string|null)} namespace the namespace to filter the children by. If
   *        null all the children will be returned.
   * @param {(string|null)} tagName the name of the tag to filter the children by.
   *        Only considered if the namespace parameter is non-null. If null, the
   *        children will not be filtered by tag name.
   * @return {Array.<adf.mf.api.amx.AmxTag>} array of all the matching children tags.
   */
  adf.mf.api.amx.AmxTag.prototype.getChildren = function(
    namespace,
    tagName)
  {
    var result = [];
    for (var i = 0, size = this._children.length; i < size; ++i)
    {
      var child = this._children[i];
      if ((namespace == null || namespace == child.getNamespace()) &&
        (tagName == null || tagName == child.getName()))
      {
        result.push(child);
      }
    }

    return result;
  };

  /**
   * Convenience function to get all of the children facet tags. Meant to assist
   * the creation of the AMX node process.
   * @return {Array.<adf.mf.api.amx.AmxTag>} array of all the facet tags.
   */
  adf.mf.api.amx.AmxTag.prototype.getChildrenFacetTags = function()
  {
    return this.getChildren(adf.mf.api.amx.AmxTag.NAMESPACE_AMX, "facet");
  };

  /**
   * Convenience function to get the facet tag with the given name. Meant to assist
   * the code if the presence of a facet changes the behavior of a type handler.
   * @param {string} name the name of the facet to find.
   * @return {(adf.mf.api.amx.AmxTag|null)} the child facet tag or null if none has been
   *         provided with the given name.
   */
  adf.mf.api.amx.AmxTag.prototype.getChildFacetTag = function(name)
  {
    var facetTags = this.getChildren(adf.mf.api.amx.AmxTag.NAMESPACE_AMX, "facet");
    for (var i = 0, size = facetTags.length; i < size; ++i)
    {
      var tag = facetTags[i];
      if (tag.getAttribute("name") == name)
      {
        return tag;
      }
    }

    return null;
  };

  /**
   * Convenience function to get all children tags that are UI tags. Meant to assist
   * the creation of the AMX node process. Does not return any facet tags.
   * @return {Array.<adf.mf.api.amx.AmxTag>} array of all the children UI tags.
   */
  adf.mf.api.amx.AmxTag.prototype.getChildrenUITags = function()
  {
    var children = this.getChildren();
    var result = children.filter(
      function(tag, index, array)
      {
        return tag.isUITag();
      });

    return result;
  };

  /**
   * Get all of the defined attribute names for the tag.
   * @return {Array.<string>} all of the attribute names for the attributes that were
   *         specified on the tag.
   */
  adf.mf.api.amx.AmxTag.prototype.getAttributeNames = function()
  {
    var names = [];
    for (var name in this._attr)
    {
      names.push(name);
    }

    return names;
  };

  /**
   * Get if the given attribute is bound to an EL expression.
   * @param {string} name the name of the attribute to check.
   * @return {boolean} true if there is EL in the attribute value or false if the value
   *         is static or if the attribute was not defined.
   */
  adf.mf.api.amx.AmxTag.prototype.isAttributeElBound = function(name)
  {
    return AmxTag.__isELExpression(this.getAttribute(name));
  };

  /**
   * Get the attribute value (may be an EL string) for the attribute of the given name.
   * @param {string} name the name of the attribute
   * @return {string|undefined} the attribute value or undefined if the attribute was not specified.
   *         Returns the expression string for EL attributes.
   */
  adf.mf.api.amx.AmxTag.prototype.getAttribute = function(name)
  {
    return this._attr[name];
  };

  /**
   * Get a k/v pair map of the attributes and their values.
   * @return {Object.<string, value>} map of name to value pairs.
   */
  adf.mf.api.amx.AmxTag.prototype.getAttributes = function()
  {
    return this._attr;
  };

  /**
   * Get if the node is a UI tag with a type handler and renders content.
   * @return {boolean} true if a UI tag
   */
  adf.mf.api.amx.AmxTag.prototype.isUITag = function()
  {
    if (this._uiTag == null)
    {
      // Lazily load the value. This ensures that the tag resources are loaded before we check
      // for a tag handler in case the tag handler is registered inside of a resource.
      var hasTagHandler = adf.mf.internal.amx.AmxTagHandler.__hasTagHandler(this._nsPrefixedName);
      this._uiTag = !hasTagHandler;
    }

    return this._uiTag;
  };

  /**
   * Get the tags for the children of this facet and the name of the facet if this tag
   * is a facet tag. Convenience function for building the AMX node tree.
   * @return {({name:string, children:Array.<adf.mf.api.amx.AmxTag>}|null)} an object with the
   *         name of the facet and the children tags of the facet. Returns null if the tag
   *         is not an AMX facet tag.
   */
  adf.mf.api.amx.AmxTag.prototype.getFacet = function()
  {
    if (this._nsPrefixedName == adf.mf.api.amx.AmxTag.NAMESPACE_AMX+":facet")
    {
      var children = this.getChildren();
      var facetName = this.getAttribute("name");

      return { "name": facetName, "children": children };
    }

    return null;
  };

  /**
   * Create a new instance of an AMX node for this tag given the stamp ID. If the tag
   * is a facet tag, the tag will create the node for the child tag. This function does
   * not initialize the node.
   *
   * @param {(adf.mf.api.amx.AmxNode|null)} parentNode the parent AMX node or null if the
   *        tag/node is the root
   * @param {(Object|null)} key the stamp key to identify the node with the given key. May
   *        be null for non-iterating parent tags.
   * @return {(adf.mf.api.amx.AmxNode|null)} an un-initialized AMX node object or null
   *         for non-UI tags
   */
  adf.mf.api.amx.AmxTag.prototype.buildAmxNode = function(
    parentNode,
    key)
  {
    if (!this.isUITag())
    {
      // Currently do nothing for other non-UI tags, but we should consider adding
      // behaviors and other types of tags in the future to remove the hard-coded nature
      // of processing tags like the AMX setPropertyListener tag.
      return null;
    }

    return new adf.mf.api.amx.AmxNode(parentNode, this, key);
  };

  /**
   * Get the type handler for this tag.
   * @return {Object} the type handler
   */
  adf.mf.api.amx.AmxTag.prototype.getTypeHandler = function()
  {
    if (this._typeHandler === undefined)
    {
      var typeHandler = null;
      if (this._nsPrefixedName)
      {
        typeHandler = adf.mf.api.amx.TypeHandler._instanceDictionary[this._nsPrefixedName];
        if (typeHandler == null)
        {
          var typeHandlerClass = adf.mf.api.amx.TypeHandler._classDictionary[this._nsPrefixedName];
          if (typeHandlerClass != null)
          {
            typeHandler = new typeHandlerClass();
            adf.mf.api.amx.TypeHandler._instanceDictionary[this._nsPrefixedName] = typeHandler;
          }
        }
      }

      if (typeHandler === undefined && adf.mf.log.AMX.isLoggable(adf.mf.log.level.FINEST))
      {
        // Could not find an associated TypeHandler.
        adf.mf.log.AMX.logp(adf.mf.log.level.FINEST,
          "adf.mf.api.amx.AmxTag", "getTypeHandler",
          "Unable to find TypeHandler for namespace = " + this._ns + ", ns prefixed name = " +
          this._nsPrefixedName + ", local name = " + this._name);
      }

      this._typeHandler = typeHandler;
    }

    return this._typeHandler;
  };

  /**
   * Internal function to check if the given value is an EL expression.
   * @param {(string|null)} value the value to check
   * @return {boolean} true if there is EL in the value or false if the value
   *         is static or if the value is null.
   * @ignore
   */
  adf.mf.api.amx.AmxTag.__isELExpression = function(value)
  {
    return value != null && value.indexOf("#{") >= 0;
  };

  /**
   * Get a type handler function (JavaScript class) for the given namespace and name.
   * Primarily used by the test JavaScript files to extend an existing type handler prototype.
   *
   * @param {string} tagNs the tag namespace
   * @param {string} tagName the tag name
   * @return {function} the type handler function if found, otherwise null
   */
  AmxTag.getTypeHandlerFunction = function(tagNs, tagName)
  {
    // Internal usage is for the first param to be the prefixed name
    var nsPrefixedName = arguments.length == 1 ? tagNs : tagNs + ":" + tagName;

    return adf.mf.api.amx.TypeHandler._classDictionary[nsPrefixedName];
  };

})();
